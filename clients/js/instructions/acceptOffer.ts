/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
  type WritableSignerAccount,
} from 'gill';
import { SWAP_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const ACCEPT_OFFER_DISCRIMINATOR = new Uint8Array([
  227, 82, 234, 131, 1, 18, 48, 2,
]);

export function getAcceptOfferDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    ACCEPT_OFFER_DISCRIMINATOR
  );
}

export type AcceptOfferInstruction<
  TProgram extends string = typeof SWAP_PROGRAM_ADDRESS,
  TAccountReciever extends string | IAccountMeta<string> = string,
  TAccountProposer extends string | IAccountMeta<string> = string,
  TAccountOffer extends string | IAccountMeta<string> = string,
  TAccountToken0Mint extends string | IAccountMeta<string> = string,
  TAccountToken1Mint extends string | IAccountMeta<string> = string,
  TAccountToken0 extends string | IAccountMeta<string> = string,
  TAccountToken1 extends string | IAccountMeta<string> = string,
  TAccountVault0 extends string | IAccountMeta<string> = string,
  TAccountVault1 extends string | IAccountMeta<string> = string,
  TAccountProposerToken1 extends string | IAccountMeta<string> = string,
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountTokenProgram extends
    | string
    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountAssociatedTokenProgram extends
    | string
    | IAccountMeta<string> = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountReciever extends string
        ? WritableSignerAccount<TAccountReciever> &
            IAccountSignerMeta<TAccountReciever>
        : TAccountReciever,
      TAccountProposer extends string
        ? ReadonlyAccount<TAccountProposer>
        : TAccountProposer,
      TAccountOffer extends string
        ? WritableAccount<TAccountOffer>
        : TAccountOffer,
      TAccountToken0Mint extends string
        ? ReadonlyAccount<TAccountToken0Mint>
        : TAccountToken0Mint,
      TAccountToken1Mint extends string
        ? ReadonlyAccount<TAccountToken1Mint>
        : TAccountToken1Mint,
      TAccountToken0 extends string
        ? WritableSignerAccount<TAccountToken0> &
            IAccountSignerMeta<TAccountToken0>
        : TAccountToken0,
      TAccountToken1 extends string
        ? WritableSignerAccount<TAccountToken1> &
            IAccountSignerMeta<TAccountToken1>
        : TAccountToken1,
      TAccountVault0 extends string
        ? WritableAccount<TAccountVault0>
        : TAccountVault0,
      TAccountVault1 extends string
        ? WritableAccount<TAccountVault1>
        : TAccountVault1,
      TAccountProposerToken1 extends string
        ? WritableAccount<TAccountProposerToken1>
        : TAccountProposerToken1,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountAssociatedTokenProgram extends string
        ? ReadonlyAccount<TAccountAssociatedTokenProgram>
        : TAccountAssociatedTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type AcceptOfferInstructionData = { discriminator: ReadonlyUint8Array };

export type AcceptOfferInstructionDataArgs = {};

export function getAcceptOfferInstructionDataEncoder(): Encoder<AcceptOfferInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]),
    (value) => ({ ...value, discriminator: ACCEPT_OFFER_DISCRIMINATOR })
  );
}

export function getAcceptOfferInstructionDataDecoder(): Decoder<AcceptOfferInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
  ]);
}

export function getAcceptOfferInstructionDataCodec(): Codec<
  AcceptOfferInstructionDataArgs,
  AcceptOfferInstructionData
> {
  return combineCodec(
    getAcceptOfferInstructionDataEncoder(),
    getAcceptOfferInstructionDataDecoder()
  );
}

export type AcceptOfferInput<
  TAccountReciever extends string = string,
  TAccountProposer extends string = string,
  TAccountOffer extends string = string,
  TAccountToken0Mint extends string = string,
  TAccountToken1Mint extends string = string,
  TAccountToken0 extends string = string,
  TAccountToken1 extends string = string,
  TAccountVault0 extends string = string,
  TAccountVault1 extends string = string,
  TAccountProposerToken1 extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
> = {
  reciever: TransactionSigner<TAccountReciever>;
  proposer: Address<TAccountProposer>;
  offer: Address<TAccountOffer>;
  token0Mint: Address<TAccountToken0Mint>;
  token1Mint: Address<TAccountToken1Mint>;
  token0: TransactionSigner<TAccountToken0>;
  token1: TransactionSigner<TAccountToken1>;
  vault0: Address<TAccountVault0>;
  vault1: Address<TAccountVault1>;
  proposerToken1: Address<TAccountProposerToken1>;
  systemProgram?: Address<TAccountSystemProgram>;
  tokenProgram?: Address<TAccountTokenProgram>;
  associatedTokenProgram?: Address<TAccountAssociatedTokenProgram>;
};

export function getAcceptOfferInstruction<
  TAccountReciever extends string,
  TAccountProposer extends string,
  TAccountOffer extends string,
  TAccountToken0Mint extends string,
  TAccountToken1Mint extends string,
  TAccountToken0 extends string,
  TAccountToken1 extends string,
  TAccountVault0 extends string,
  TAccountVault1 extends string,
  TAccountProposerToken1 extends string,
  TAccountSystemProgram extends string,
  TAccountTokenProgram extends string,
  TAccountAssociatedTokenProgram extends string,
  TProgramAddress extends Address = typeof SWAP_PROGRAM_ADDRESS,
>(
  input: AcceptOfferInput<
    TAccountReciever,
    TAccountProposer,
    TAccountOffer,
    TAccountToken0Mint,
    TAccountToken1Mint,
    TAccountToken0,
    TAccountToken1,
    TAccountVault0,
    TAccountVault1,
    TAccountProposerToken1,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): AcceptOfferInstruction<
  TProgramAddress,
  TAccountReciever,
  TAccountProposer,
  TAccountOffer,
  TAccountToken0Mint,
  TAccountToken1Mint,
  TAccountToken0,
  TAccountToken1,
  TAccountVault0,
  TAccountVault1,
  TAccountProposerToken1,
  TAccountSystemProgram,
  TAccountTokenProgram,
  TAccountAssociatedTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? SWAP_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    reciever: { value: input.reciever ?? null, isWritable: true },
    proposer: { value: input.proposer ?? null, isWritable: false },
    offer: { value: input.offer ?? null, isWritable: true },
    token0Mint: { value: input.token0Mint ?? null, isWritable: false },
    token1Mint: { value: input.token1Mint ?? null, isWritable: false },
    token0: { value: input.token0 ?? null, isWritable: true },
    token1: { value: input.token1 ?? null, isWritable: true },
    vault0: { value: input.vault0 ?? null, isWritable: true },
    vault1: { value: input.vault1 ?? null, isWritable: true },
    proposerToken1: { value: input.proposerToken1 ?? null, isWritable: true },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    associatedTokenProgram: {
      value: input.associatedTokenProgram ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Resolve default values.
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.associatedTokenProgram.value) {
    accounts.associatedTokenProgram.value =
      'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.reciever),
      getAccountMeta(accounts.proposer),
      getAccountMeta(accounts.offer),
      getAccountMeta(accounts.token0Mint),
      getAccountMeta(accounts.token1Mint),
      getAccountMeta(accounts.token0),
      getAccountMeta(accounts.token1),
      getAccountMeta(accounts.vault0),
      getAccountMeta(accounts.vault1),
      getAccountMeta(accounts.proposerToken1),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.associatedTokenProgram),
    ],
    programAddress,
    data: getAcceptOfferInstructionDataEncoder().encode({}),
  } as AcceptOfferInstruction<
    TProgramAddress,
    TAccountReciever,
    TAccountProposer,
    TAccountOffer,
    TAccountToken0Mint,
    TAccountToken1Mint,
    TAccountToken0,
    TAccountToken1,
    TAccountVault0,
    TAccountVault1,
    TAccountProposerToken1,
    TAccountSystemProgram,
    TAccountTokenProgram,
    TAccountAssociatedTokenProgram
  >;

  return instruction;
}

export type ParsedAcceptOfferInstruction<
  TProgram extends string = typeof SWAP_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    reciever: TAccountMetas[0];
    proposer: TAccountMetas[1];
    offer: TAccountMetas[2];
    token0Mint: TAccountMetas[3];
    token1Mint: TAccountMetas[4];
    token0: TAccountMetas[5];
    token1: TAccountMetas[6];
    vault0: TAccountMetas[7];
    vault1: TAccountMetas[8];
    proposerToken1: TAccountMetas[9];
    systemProgram: TAccountMetas[10];
    tokenProgram: TAccountMetas[11];
    associatedTokenProgram: TAccountMetas[12];
  };
  data: AcceptOfferInstructionData;
};

export function parseAcceptOfferInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedAcceptOfferInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      reciever: getNextAccount(),
      proposer: getNextAccount(),
      offer: getNextAccount(),
      token0Mint: getNextAccount(),
      token1Mint: getNextAccount(),
      token0: getNextAccount(),
      token1: getNextAccount(),
      vault0: getNextAccount(),
      vault1: getNextAccount(),
      proposerToken1: getNextAccount(),
      systemProgram: getNextAccount(),
      tokenProgram: getNextAccount(),
      associatedTokenProgram: getNextAccount(),
    },
    data: getAcceptOfferInstructionDataDecoder().decode(instruction.data),
  };
}
